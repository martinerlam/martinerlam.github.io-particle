<!doctype html>
<!--
  RenderHeads Fluid Cubes — v0.3.3a-spinfix-debug-logo-stable
  Based on v0.3.2a hotfix stability.

  Includes:
  - Instanced cubes + motion + interaction stirring + lighting controls
  - Debug overlay improvements (guarded):
      * Velocity arrows (pointer + blob)
      * Heat influence ring (soft radial falloff)
      * Legend text (radius, strength, invert, stirEnabled)
  - Top-right logo overlay: "Renderheads Logos-02.png"
  - Spin FIX: visibly rotates cube vertices (Y + subtle X) so Spin is clearly working
-->
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Fluid Cubes — v0.3.3a</title>
  <style>
    html, body { margin:0; height:100%; background:#06070a; overflow:hidden; }
    #c { width:100%; height:100%; display:block; }
    #dbg { position:fixed; inset:0; pointer-events:none; }

    /* Top-right logo overlay */
    #logo {
      position: fixed;
      top: 12px;
      right: 12px;
      width: 170px;
      height: auto;
      opacity: 0.92;
      user-select: none;
      pointer-events: none;
      filter: drop-shadow(0 6px 16px rgba(0,0,0,0.45));
      z-index: 9;
    }
    #logo.hidden { display:none; }

    #err {
      position: fixed;
      left: 12px; bottom: 12px;
      max-width: min(720px, calc(100vw - 24px));
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255, 60, 80, 0.14);
      border: 1px solid rgba(255, 60, 80, 0.35);
      color: rgba(255,255,255,0.95);
      font: 12px/1.35 ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      backdrop-filter: blur(10px);
      white-space: pre-wrap;
      display: none;
      z-index: 9999;
    }

    .panel{
      position:fixed;
      left:12px; top:12px;
      width:min(460px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow:auto;
      color:rgba(255,255,255,.92);
      background:rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      padding:12px 12px 10px 12px;
      font:12px/1.25 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
      backdrop-filter: blur(10px);
      user-select:none;
      z-index: 10;
    }
    .title{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      position:sticky;
      top:0;
      padding-top:2px;
      background:rgba(0,0,0,.10);
      backdrop-filter: blur(10px);
      z-index: 2;
    }
    .title b{ font-weight:700; letter-spacing:.2px; }
    .meta{ opacity:.85; font-variant-numeric: tabular-nums; white-space:nowrap; }
    .sectionTitle{ margin-top:10px; font-weight:700; opacity:.95; letter-spacing:.2px; }
    .row{
      display:grid;
      grid-template-columns: 140px 1fr 60px;
      gap:10px;
      align-items:center;
      padding:6px 0;
    }
    .row label{ opacity:.9; }
    input[type="range"]{ width:100%; }
    input[type="color"]{
      width:100%;
      height:28px;
      padding:0;
      border:none;
      background:transparent;
      cursor:pointer;
    }
    select{
      width:100%;
      height:28px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:0 10px;
      outline:none;
    }
    details{
      border:1px solid rgba(255,255,255,.10);
      border-radius:12px;
      padding:8px 10px;
      margin-top:10px;
      background:rgba(255,255,255,.03);
    }
    summary{
      cursor:pointer;
      font-weight:700;
      opacity:.95;
      list-style:none;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
    }
    summary::-webkit-details-marker{ display:none; }
    .chev{ opacity:.7; font-weight:900; }

    .toggleRow{
      display:flex;
      gap:10px;
      align-items:center;
      padding:6px 0 2px 0;
    }
    .toggleRow input{ transform: translateY(1px); }

    .btnrow{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      margin-top:10px;
    }
    button{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      color:rgba(255,255,255,.92);
      padding:7px 10px;
      border-radius:10px;
      cursor:pointer;
      font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    }
    button:hover{ background:rgba(255,255,255,.10); }
    button:active{ transform: translateY(1px); }
    button.primary{ background:rgba(255,255,255,.12); border-color: rgba(255,255,255,.18); }
    button.toggled{ background: rgba(100, 200, 255, .16); border-color: rgba(100, 200, 255, .28); }
    .hint{ margin-top:10px; opacity:.75; font-size:11px; line-height:1.3; }
    .hidden{ display:none; }
    .pill{
      padding:2px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      font-variant-numeric: tabular-nums;
    }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<canvas id="dbg"></canvas>

<img id="logo" src="Renderheads Logos-02.png" alt="RenderHeads" />

<div id="err"></div>

<div id="ui" class="panel">
  <div class="title">
    <div><b>Fluid Cubes</b> <span class="pill">v0.3.3a</span></div>
    <div class="meta"><span id="fps">FPS: —</span> · <span id="countLabel">cubes: —</span></div>
  </div>

  <div class="sectionTitle">Motion</div>
  <div class="row"><label for="amp">Amp</label><input id="amp" type="range" min="0" max="1.5" step="0.01" value="0.55" /><div id="ampV" class="meta">0.55</div></div>
  <div class="row"><label for="speed">Speed</label><input id="speed" type="range" min="0" max="2.0" step="0.01" value="0.55" /><div id="speedV" class="meta">0.55</div></div>
  <div class="row"><label for="cubeScale">Cube size</label><input id="cubeScale" type="range" min="0.25" max="2.50" step="0.01" value="1.00" /><div id="cubeScaleV" class="meta">1.00</div></div>
  <div class="row"><label for="spin">Spin</label><input id="spin" type="range" min="0" max="3.0" step="0.01" value="0.85" /><div id="spinV" class="meta">0.85</div></div>

  <div class="sectionTitle">Colour</div>
  <div class="row">
    <label for="colorMode">Colour mode</label>
    <select id="colorMode">
      <option value="0">Solid</option>
      <option value="1" selected>Gradient (height)</option>
      <option value="2">Seed mix (per cube)</option>
    </select>
    <div class="meta"></div>
  </div>
  <div class="row"><label for="colorA">Colour A</label><input id="colorA" type="color" value="#3aa0ff" /><div class="meta"></div></div>
  <div class="row"><label for="colorB">Colour B</label><input id="colorB" type="color" value="#ff3a8a" /><div class="meta"></div></div>
  <div class="row"><label for="brightness">Brightness</label><input id="brightness" type="range" min="0" max="2.0" step="0.01" value="1.00" /><div id="brightnessV" class="meta">1.00</div></div>

  <div class="sectionTitle">Interaction</div>
  <div class="row"><label for="stirStrength">Stir strength</label><input id="stirStrength" type="range" min="0" max="3.0" step="0.01" value="1.20" /><div id="stirStrengthV" class="meta">1.20</div></div>
  <div class="row"><label for="stirRadius">Stir radius</label><input id="stirRadius" type="range" min="0.05" max="2.5" step="0.01" value="0.80" /><div id="stirRadiusV" class="meta">0.80</div></div>
  <div class="row"><label for="stirPersist">Stir persistence</label><input id="stirPersist" type="range" min="0" max="2.5" step="0.01" value="1.10" /><div id="stirPersistV" class="meta">1.10</div></div>
  <div class="row"><label for="stirDecay">Stir decay</label><input id="stirDecay" type="range" min="0.5" max="6.0" step="0.01" value="2.40" /><div id="stirDecayV" class="meta">2.40</div></div>
  <div class="toggleRow"><input id="invertStir" type="checkbox" /><label for="invertStir">Invert stir direction</label></div>
  <div class="toggleRow"><input id="debugField" type="checkbox" /><label for="debugField">Debug field (D)</label></div>

  <details id="lightingDetails">
    <summary><span>Lighting</span><span class="chev">▾</span></summary>
    <div class="toggleRow"><input id="lightsEnabled" type="checkbox" checked /><label for="lightsEnabled">Enable lights</label></div>
    <div class="toggleRow"><input id="shadowsEnabled" type="checkbox" /><label for="shadowsEnabled">Shadows (heavy)</label></div>
    <div class="row"><label for="ambientI">Ambient</label><input id="ambientI" type="range" min="0" max="2.5" step="0.01" value="0.45" /><div id="ambientIV" class="meta">0.45</div></div>
    <div class="sectionTitle">Key light</div>
    <div class="row"><label for="keyI">Intensity</label><input id="keyI" type="range" min="0" max="5.0" step="0.01" value="1.00" /><div id="keyIV" class="meta">1.00</div></div>
    <div class="row"><label for="keyAz">Azimuth</label><input id="keyAz" type="range" min="-180" max="180" step="1" value="35" /><div id="keyAzV" class="meta">35</div></div>
    <div class="row"><label for="keyEl">Elevation</label><input id="keyEl" type="range" min="-5" max="89" step="1" value="55" /><div id="keyElV" class="meta">55</div></div>
    <div class="sectionTitle">Fill light</div>
    <div class="row"><label for="fillI">Intensity</label><input id="fillI" type="range" min="0" max="5.0" step="0.01" value="0.55" /><div id="fillIV" class="meta">0.55</div></div>
    <div class="row"><label for="fillAz">Azimuth</label><input id="fillAz" type="range" min="-180" max="180" step="1" value="-55" /><div id="fillAzV" class="meta">-55</div></div>
    <div class="row"><label for="fillEl">Elevation</label><input id="fillEl" type="range" min="-5" max="89" step="1" value="25" /><div id="fillElV" class="meta">25</div></div>
    <div class="sectionTitle">Rim light</div>
    <div class="row"><label for="rimI">Intensity</label><input id="rimI" type="range" min="0" max="5.0" step="0.01" value="0.80" /><div id="rimIV" class="meta">0.80</div></div>
    <div class="row"><label for="rimAz">Azimuth</label><input id="rimAz" type="range" min="-180" max="180" step="1" value="170" /><div id="rimAzV" class="meta">170</div></div>
    <div class="row"><label for="rimEl">Elevation</label><input id="rimEl" type="range" min="-5" max="89" step="1" value="10" /><div id="rimElV" class="meta">10</div></div>
  </details>

  <details id="materialDetails">
    <summary><span>Material</span><span class="chev">▾</span></summary>
    <div class="row"><label for="rough">Roughness</label><input id="rough" type="range" min="0" max="1" step="0.01" value="0.55" /><div id="roughV" class="meta">0.55</div></div>
    <div class="row"><label for="metal">Metalness</label><input id="metal" type="range" min="0" max="1" step="0.01" value="0.10" /><div id="metalV" class="meta">0.10</div></div>
  </details>

  <div class="btnrow">
    <button id="b2k">2k (1)</button>
    <button id="b8k" class="primary">8k (2)</button>
    <button id="b20k">20k (3)</button>
    <button id="pause">Pause (Space)</button>
    <button id="reset">Reset (R)</button>
    <button id="stirToggle" class="toggled">Stir: ON (M)</button>
    <button id="hide">Hide UI (H)</button>
  </div>

  <div class="hint">
    <b>Left-drag</b>: rotate · Wheel: zoom · <b>Right-drag</b>: stir · Touch-drag: stir<br>
    Hotkeys: <b>Space</b> pause, <b>R</b> reset, <b>1/2/3</b> cube count, <b>M</b> stir, <b>D</b> debug, <b>H</b> UI
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const errEl = document.getElementById("err");
function showError(e){
  const msg = (e && (e.stack || e.message)) ? (e.stack || e.message) : String(e);
  errEl.style.display = "block";
  errEl.textContent = "⚠️ Runtime error:\n" + msg;
  console.error(e);
}
addEventListener("error", (ev) => showError(ev.error || ev.message));
addEventListener("unhandledrejection", (ev) => showError(ev.reason));

try {
  const canvas = document.getElementById("c");
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.setSize(innerWidth, innerHeight);
  renderer.setClearColor(0x06070a, 1);
  renderer.debug.checkShaderErrors = true;

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x06070a, 0.10);

  // Logo safety: hide if it fails to load
  const logoEl = document.getElementById("logo");
  logoEl.addEventListener("error", () => {
    logoEl.classList.add("hidden");
    console.warn("Logo image not found: Renderheads Logos-02.png");
  });

  // Debug overlay (guarded)
  const dbgCanvas = document.getElementById("dbg");
  const dbg = dbgCanvas.getContext("2d", { alpha:true });
  const hasDbg = !!dbg;

  // Camera (orbit)
  const camera = new THREE.PerspectiveCamera(55, innerWidth / innerHeight, 0.01, 200);
  let camTarget = new THREE.Vector3(0, 0, 0);
  let camRadius = 6.0;
  let camTheta  = 1.25;
  let camPhi    = 0.25;

  function updateCamera(){
    camTheta = Math.max(0.02, Math.min(Math.PI - 0.02, camTheta));
    const x = camRadius * Math.sin(camTheta) * Math.sin(camPhi);
    const y = camRadius * Math.cos(camTheta);
    const z = camRadius * Math.sin(camTheta) * Math.cos(camPhi);
    camera.position.set(camTarget.x + x, camTarget.y + y, camTarget.z + z);
    camera.lookAt(camTarget);
  }
  updateCamera();

  canvas.addEventListener("contextmenu", (e) => e.preventDefault());

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.45);
  scene.add(ambient);

  const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
  const fillLight = new THREE.DirectionalLight(0xffffff, 0.55);
  const rimLight = new THREE.DirectionalLight(0xffffff, 0.80);
  scene.add(keyLight, fillLight, rimLight);

  function setLightDir(light, azDeg, elDeg, radius=8){
    const az = azDeg * Math.PI / 180;
    const el = elDeg * Math.PI / 180;
    const x = radius * Math.cos(el) * Math.sin(az);
    const y = radius * Math.sin(el);
    const z = radius * Math.cos(el) * Math.cos(az);
    light.position.set(x, y, z);
    light.target.position.set(0,0,0);
    if (!light.target.parent) scene.add(light.target);
  }

  // Params / Geometry
  const CUBE_SIZE = 0.03;
  const FLOW_SCALE_FIXED = 0.95;
  const VOLUME = new THREE.Vector3(2.3, 1.5, 2.3);
  const geometry = new THREE.BoxGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);

  const params = {
    amp: 0.55, speed: 0.55, cubeScale: 1.0, spin: 0.85,
    stirStrength: 1.2, stirRadius: 0.8, stirEnabled: true,
    stirPersist: 1.10, stirDecay: 2.40, invertStir: false,
    debugField: false,

    colorMode: 1,
    colorA: new THREE.Color("#3aa0ff"),
    colorB: new THREE.Color("#ff3a8a"),
    brightness: 1.0,

    lightsEnabled: true,
    shadowsEnabled: false,
    ambientI: 0.45,
    keyI: 1.0, keyAz: 35, keyEl: 55,
    fillI: 0.55, fillAz: -55, fillEl: 25,
    rimI: 0.80, rimAz: 170, rimEl: 10,

    roughness: 0.55,
    metalness: 0.10,
  };

  // Interaction
  const raycaster = new THREE.Raycaster();
  const ndc = new THREE.Vector2();
  const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
  const hit = new THREE.Vector3();

  let isStirDrag = false;
  let isOrbitDrag = false;
  let lastOrbitX = 0, lastOrbitY = 0;

  let pointerWorld = new THREE.Vector3();
  let lastPointerWorld = new THREE.Vector3();
  let pointerVel = new THREE.Vector3();
  let velSmoothed = new THREE.Vector3();
  let lastPointerTime = performance.now();

  function setNDCFromEvent(e){
    const r = canvas.getBoundingClientRect();
    ndc.x = ((e.clientX - r.left) / r.width) * 2 - 1;
    ndc.y = -(((e.clientY - r.top) / r.height) * 2 - 1);
  }
  function updatePointerWorldFromNDC(){
    raycaster.setFromCamera(ndc, camera);
    raycaster.ray.intersectPlane(plane, hit);
    if (Number.isFinite(hit.x)) pointerWorld.copy(hit);
  }
  function updatePointerVelocity(){
    const now = performance.now();
    const dt = Math.max(0.001, (now - lastPointerTime) / 1000);
    lastPointerTime = now;
    const rawVel = pointerWorld.clone().sub(lastPointerWorld).divideScalar(dt);
    lastPointerWorld.copy(pointerWorld);
    velSmoothed.lerp(rawVel, 0.22);
    pointerVel.copy(velSmoothed);
  }

  const stirState = { pos: new THREE.Vector3(), vel: new THREE.Vector3(), strength: 0.0, age: 999.0 };
  function injectStirBlob(){
    stirState.pos.copy(pointerWorld);
    stirState.vel.copy(pointerVel);
    stirState.strength = Math.min(1.0, stirState.strength + 0.35);
    stirState.age = 0.0;
  }

  // Material injection
  function makeInjectedMaterial(){
    const mat = new THREE.MeshStandardMaterial({
      roughness: params.roughness,
      metalness: params.metalness,
    });

    mat.onBeforeCompile = (shader) => {
      shader.uniforms.uTime  = { value: 0 };
      shader.uniforms.uAmp   = { value: params.amp };
      shader.uniforms.uSpeed = { value: params.speed };
      shader.uniforms.uSpin  = { value: params.spin };
      shader.uniforms.uCubeScale = { value: params.cubeScale };

      shader.uniforms.uStirEnabled  = { value: params.stirEnabled ? 1.0 : 0.0 };
      shader.uniforms.uStirStrength = { value: params.stirStrength };
      shader.uniforms.uStirRadius   = { value: params.stirRadius };
      shader.uniforms.uInvertStir   = { value: params.invertStir ? 1.0 : 0.0 };

      shader.uniforms.uPointerPos   = { value: new THREE.Vector3(0,0,0) };
      shader.uniforms.uPointerVel   = { value: new THREE.Vector3(0,0,0) };

      shader.uniforms.uBlobPos      = { value: new THREE.Vector3(0,0,0) };
      shader.uniforms.uBlobVel      = { value: new THREE.Vector3(0,0,0) };
      shader.uniforms.uBlobStrength = { value: 0.0 };

      shader.uniforms.uColorMode   = { value: params.colorMode };
      shader.uniforms.uColorA      = { value: params.colorA.clone() };
      shader.uniforms.uColorB      = { value: params.colorB.clone() };
      shader.uniforms.uBrightness  = { value: params.brightness };
      shader.uniforms.uHeightMin   = { value: -VOLUME.y };
      shader.uniforms.uHeightMax   = { value:  VOLUME.y };

      shader.vertexShader = shader.vertexShader.replace(
        "#include <common>",
`#include <common>
uniform float uTime;
uniform float uAmp;
uniform float uSpeed;
uniform float uSpin;
uniform float uCubeScale;

uniform float uStirEnabled;
uniform float uStirStrength;
uniform float uStirRadius;
uniform float uInvertStir;
uniform vec3  uPointerPos;
uniform vec3  uPointerVel;

uniform vec3  uBlobPos;
uniform vec3  uBlobVel;
uniform float uBlobStrength;

uniform float uColorMode;
uniform float uHeightMin;
uniform float uHeightMax;

varying float vSeedMix;
varying float vHeightT;

float hash11(float p){
  p = fract(p * 0.1031);
  p *= p + 33.33;
  p *= p + p;
  return fract(p);
}

vec3 vortexField(vec3 p, float t){
  float a = sin(p.y + t) + cos(p.z * 1.3 - t * 0.7);
  float b = sin(p.z + t * 0.9) + cos(p.x * 1.1 + t * 0.6);
  float c = sin(p.x - t * 0.8) + cos(p.y * 1.2 + t * 0.5);
  vec3 v = vec3(a - b, b - c, c - a);
  return normalize(v + 1e-6);
}

vec3 stirVortex(vec3 p, vec3 center, vec3 vel, float radius, float strength, float invertFlag){
  vec3 d = p - center;
  float dist = length(d);
  float s = exp(- (dist*dist) / max(1e-4, radius*radius));

  vec3 vdir = normalize(vel + vec3(0.0001));
  vec3 axis = normalize(vec3(-vdir.y, vdir.x, 0.35));

  vec3 swirl = cross(axis, normalize(d + 1e-6));
  float vmag = clamp(length(vel) * 0.12, 0.0, 2.5);

  float inv = (invertFlag > 0.5) ? -1.0 : 1.0;
  return swirl * (strength * s * vmag * inv);
}
`
      );

      shader.vertexShader = shader.vertexShader.replace(
        "#include <begin_vertex>",
`#include <begin_vertex>
#ifdef USE_INSTANCING
  transformed *= uCubeScale;

  vec3 base = instanceMatrix[3].xyz;

  float r1 = hash11(dot(base, vec3(12.9898, 78.233, 37.719)));
  float r2 = hash11(dot(base, vec3(39.3468, 11.135, 83.155)));

  float t = uTime * uSpeed + r1 * 10.0;

  vec3 p = base * ${FLOW_SCALE_FIXED.toFixed(4)} + vec3(r2, r1, r2) * 2.0;

  vec3 v1 = vortexField(p, t * 0.9);
  vec3 v2 = vortexField(p + v1 * 0.35, t * 0.9);
  vec3 flow = normalize(v1 + v2);

  vec3 stir = vec3(0.0);
  if (uStirEnabled > 0.5) {
    stir += stirVortex(base, uPointerPos, uPointerVel, uStirRadius, uStirStrength, uInvertStir);
    stir += stirVortex(base, uBlobPos, uBlobVel, uStirRadius * 1.25, uStirStrength * uBlobStrength, uInvertStir);
  }

  vec3 combined = normalize(flow + stir);
  transformed += combined * uAmp;

  // --- Spin FIX: rotate cube local vertices (obvious spin) ---
  float angY = t * uSpin + r2 * 6.2831853;
  float cy = cos(angY), sy = sin(angY);
  mat2 rotY = mat2(cy, -sy, sy, cy);
  transformed.xz = rotY * transformed.xz;

  float angX = t * (uSpin * 0.55) + r1 * 6.2831853;
  float cx = cos(angX), sx = sin(angX);
  mat2 rotX = mat2(cx, -sx, sx, cx);
  transformed.yz = rotX * transformed.yz;

  vSeedMix = r2;
  vHeightT = clamp((base.y - uHeightMin) / max(1e-3, (uHeightMax - uHeightMin)), 0.0, 1.0);
#else
  vSeedMix = 0.5;
  vHeightT = 0.5;
#endif
`
      );

      shader.fragmentShader = shader.fragmentShader.replace(
        "#include <common>",
`#include <common>
uniform float uColorMode;
uniform vec3  uColorA;
uniform vec3  uColorB;
uniform float uBrightness;
varying float vSeedMix;
varying float vHeightT;
`
      );

      shader.fragmentShader = shader.fragmentShader.replace(
        "vec4 diffuseColor = vec4( diffuse, opacity );",
`vec3 baseCol;
if (uColorMode < 0.5) baseCol = uColorA;
else if (uColorMode < 1.5) baseCol = mix(uColorA, uColorB, vHeightT);
else baseCol = mix(uColorA, uColorB, vSeedMix);
baseCol *= uBrightness;
vec4 diffuseColor = vec4(baseCol, opacity);
`
      );

      mat.userData.shader = shader;
    };

    return mat;
  }

  // Instanced mesh
  let mesh = null;
  let material = null;
  let currentCount = 8000;

  function applyRandomDistribution(count){
    if (!mesh) return;
    const dummy = new THREE.Object3D();
    for (let i = 0; i < count; i++) {
      dummy.position.set(
        (Math.random() * 2 - 1) * VOLUME.x,
        (Math.random() * 2 - 1) * VOLUME.y,
        (Math.random() * 2 - 1) * VOLUME.z
      );
      dummy.rotation.set(0, 0, 0);
      dummy.scale.set(1, 1, 1);
      dummy.updateMatrix();
      mesh.setMatrixAt(i, dummy.matrix);
    }
    mesh.instanceMatrix.needsUpdate = true;
  }

  function applyMaterial(){
    if (!material) return;
    material.roughness = params.roughness;
    material.metalness = params.metalness;
    material.needsUpdate = true;
  }

  function applyLighting(){
    const enabled = params.lightsEnabled;

    ambient.visible = enabled;
    keyLight.visible = enabled;
    fillLight.visible = enabled;
    rimLight.visible = enabled;

    ambient.intensity = params.ambientI;

    keyLight.intensity = params.keyI;
    fillLight.intensity = params.fillI;
    rimLight.intensity = params.rimI;

    setLightDir(keyLight, params.keyAz, params.keyEl, 9);
    setLightDir(fillLight, params.fillAz, params.fillEl, 9);
    setLightDir(rimLight, params.rimAz, params.rimEl, 9);

    renderer.shadowMap.enabled = params.shadowsEnabled && enabled;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    keyLight.castShadow = params.shadowsEnabled && enabled;
    fillLight.castShadow = false;
    rimLight.castShadow = false;

    const s = 18;
    keyLight.shadow.mapSize.set(1024, 1024);
    keyLight.shadow.camera.left = -s;
    keyLight.shadow.camera.right = s;
    keyLight.shadow.camera.top = s;
    keyLight.shadow.camera.bottom = -s;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 40;
    keyLight.shadow.bias = -0.0004;

    if (mesh) {
      mesh.castShadow = params.shadowsEnabled && enabled;
      mesh.receiveShadow = params.shadowsEnabled && enabled;
    }
  }

  function setUniformsLive(){
    const sh = material?.userData?.shader;
    if (!sh) return;

    sh.uniforms.uAmp.value = params.amp;
    sh.uniforms.uSpeed.value = params.speed;
    sh.uniforms.uSpin.value = params.spin;
    sh.uniforms.uCubeScale.value = params.cubeScale;

    sh.uniforms.uStirStrength.value = params.stirStrength;
    sh.uniforms.uStirRadius.value = params.stirRadius;
    sh.uniforms.uStirEnabled.value = params.stirEnabled ? 1.0 : 0.0;
    sh.uniforms.uInvertStir.value = params.invertStir ? 1.0 : 0.0;

    sh.uniforms.uColorMode.value = params.colorMode;
    sh.uniforms.uColorA.value.copy(params.colorA);
    sh.uniforms.uColorB.value.copy(params.colorB);
    sh.uniforms.uBrightness.value = params.brightness;
  }

  function buildMesh(count){
    if (mesh) scene.remove(mesh);
    if (material) material.dispose();

    material = makeInjectedMaterial();
    mesh = new THREE.InstancedMesh(geometry, material, count);
    mesh.frustumCulled = false;
    scene.add(mesh);

    applyRandomDistribution(count);

    currentCount = count;
    document.getElementById("countLabel").textContent = `cubes: ${currentCount.toLocaleString()}`;

    applyMaterial();
    applyLighting();
    setUniformsLive();
  }

  // Debug overlay helpers
  const _proj = new THREE.Vector3();
  const _proj2 = new THREE.Vector3();

  if (hasDbg && !dbg.roundRect) {
    dbg.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
    };
  }

  function resizeAll(){
    renderer.setSize(innerWidth, innerHeight);
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();

    if (hasDbg) {
      dbgCanvas.width = Math.floor(innerWidth * devicePixelRatio);
      dbgCanvas.height = Math.floor(innerHeight * devicePixelRatio);
      dbgCanvas.style.width = innerWidth + "px";
      dbgCanvas.style.height = innerHeight + "px";
      dbg.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
    }
  }
  addEventListener("resize", resizeAll);
  resizeAll();

  function worldToScreen(v){
    _proj.copy(v).project(camera);
    const w = hasDbg ? (dbgCanvas.width / devicePixelRatio) : innerWidth;
    const h = hasDbg ? (dbgCanvas.height / devicePixelRatio) : innerHeight;
    const x = (_proj.x * 0.5 + 0.5) * w;
    const y = (-_proj.y * 0.5 + 0.5) * h;
    return { x, y, z: _proj.z };
  }

  function worldRadiusToPixels(center, r){
    _proj.copy(center).project(camera);
    _proj2.copy(center).add(new THREE.Vector3(r, 0, 0)).project(camera);

    const w = hasDbg ? (dbgCanvas.width / devicePixelRatio) : innerWidth;
    const h = hasDbg ? (dbgCanvas.height / devicePixelRatio) : innerHeight;

    const x1 = (_proj.x * 0.5 + 0.5) * w;
    const y1 = (-_proj.y * 0.5 + 0.5) * h;
    const x2 = (_proj2.x * 0.5 + 0.5) * w;
    const y2 = (-_proj2.y * 0.5 + 0.5) * h;
    return Math.hypot(x2 - x1, y2 - y1);
  }

  function clearDebug(){
    if (!hasDbg) return;
    dbg.clearRect(0, 0, dbgCanvas.width, dbgCanvas.height);
  }

  function drawArrow(x1, y1, x2, y2, head=9){
    if (!hasDbg) return;
    dbg.beginPath();
    dbg.moveTo(x1, y1);
    dbg.lineTo(x2, y2);
    dbg.stroke();

    const a = Math.atan2(y2 - y1, x2 - x1);
    dbg.beginPath();
    dbg.moveTo(x2, y2);
    dbg.lineTo(x2 - Math.cos(a - 0.55) * head, y2 - Math.sin(a - 0.55) * head);
    dbg.lineTo(x2 - Math.cos(a + 0.55) * head, y2 - Math.sin(a + 0.55) * head);
    dbg.closePath();
    dbg.fill();
  }

  function drawHeatDisc(x, y, r, rgbaInner, rgbaOuter){
    if (!hasDbg) return;
    const g = dbg.createRadialGradient(x, y, 0, x, y, Math.max(1, r));
    g.addColorStop(0.0, rgbaInner);
    g.addColorStop(1.0, rgbaOuter);
    dbg.fillStyle = g;
    dbg.beginPath();
    dbg.arc(x, y, r, 0, Math.PI * 2);
    dbg.fill();
  }

  function drawLegend(lines){
    if (!hasDbg) return;
    const pad = 10;
    const x = 12;
    const y = 12;
    const lh = 14;

    dbg.save();
    dbg.font = "12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";

    let w = 0;
    for (const s of lines) w = Math.max(w, dbg.measureText(s).width);
    const boxW = Math.ceil(w) + pad * 2;
    const boxH = lines.length * lh + pad * 2;

    dbg.fillStyle = "rgba(0,0,0,0.35)";
    dbg.strokeStyle = "rgba(255,255,255,0.12)";
    dbg.lineWidth = 1;
    dbg.roundRect(x, y, boxW, boxH, 10);
    dbg.fill();
    dbg.stroke();

    dbg.fillStyle = "rgba(255,255,255,0.88)";
    for (let i = 0; i < lines.length; i++){
      dbg.fillText(lines[i], x + pad, y + pad + (i+1) * lh - 4);
    }
    dbg.restore();
  }

  function drawDebug(){
    if (!hasDbg) return;

    clearDebug();
    dbg.save();

    const ps = worldToScreen(pointerWorld);
    const pr = worldRadiusToPixels(pointerWorld, params.stirRadius);

    const bs = worldToScreen(stirState.pos);
    const br = worldRadiusToPixels(stirState.pos, params.stirRadius * 1.25);

    // Heat discs
    if (ps.z < 1.0 && params.stirEnabled) {
      const liveAlpha = isStirDrag ? 0.28 : 0.12;
      drawHeatDisc(ps.x, ps.y, pr, `rgba(120,255,170,${liveAlpha})`, "rgba(120,255,170,0.0)");
    }
    if (bs.z < 1.0 && params.stirEnabled && stirState.strength > 0.01) {
      const a = 0.18 + 0.25 * stirState.strength;
      drawHeatDisc(bs.x, bs.y, br, `rgba(255,140,220,${a})`, "rgba(255,140,220,0.0)");
    }

    // Rings + arrows
    if (ps.z < 1.0) {
      dbg.fillStyle   = "rgba(120,255,170,0.95)";
      dbg.strokeStyle = "rgba(120,255,170,0.55)";
      dbg.lineWidth = 2;

      dbg.beginPath(); dbg.arc(ps.x, ps.y, 5, 0, Math.PI*2); dbg.fill();
      dbg.beginPath(); dbg.arc(ps.x, ps.y, pr, 0, Math.PI*2); dbg.stroke();

      const pvEndW = pointerWorld.clone().add(pointerVel.clone().multiplyScalar(0.05));
      const pvS = worldToScreen(pvEndW);
      dbg.strokeStyle = "rgba(120,255,170,0.85)";
      dbg.fillStyle   = "rgba(120,255,170,0.85)";
      drawArrow(ps.x, ps.y, pvS.x, pvS.y, 9);
    }

    if (bs.z < 1.0 && stirState.strength > 0.01) {
      dbg.fillStyle   = `rgba(255,140,220,${0.45 + 0.55*stirState.strength})`;
      dbg.strokeStyle = `rgba(255,140,220,${0.25 + 0.55*stirState.strength})`;
      dbg.lineWidth = 2;

      dbg.beginPath(); dbg.arc(bs.x, bs.y, 5, 0, Math.PI*2); dbg.fill();
      dbg.beginPath(); dbg.arc(bs.x, bs.y, br, 0, Math.PI*2); dbg.stroke();

      const bvEndW = stirState.pos.clone().add(stirState.vel.clone().multiplyScalar(0.05));
      const bvS = worldToScreen(bvEndW);
      dbg.strokeStyle = `rgba(255,140,220,${0.25 + 0.75*stirState.strength})`;
      dbg.fillStyle   = `rgba(255,140,220,${0.25 + 0.75*stirState.strength})`;
      drawArrow(bs.x, bs.y, bvS.x, bvS.y, 9);
    }

    const decayRate = params.stirDecay / Math.max(0.05, params.stirPersist);
    drawLegend([
      `debug ctx: ${hasDbg ? "yes" : "no"}`,
      `stirEnabled: ${params.stirEnabled ? "true" : "false"}   invert: ${params.invertStir ? "true" : "false"}`,
      `radius: ${params.stirRadius.toFixed(2)}   blobStrength: ${stirState.strength.toFixed(2)}`,
      `persist: ${params.stirPersist.toFixed(2)}   decay: ${params.stirDecay.toFixed(2)}   rate: ${decayRate.toFixed(2)}`,
      `dragging: ${isStirDrag ? "true" : "false"}`
    ]);

    dbg.restore();
  }

  // Input: left orbit, right stir, touch stir
  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    const isTouch = e.pointerType === "touch";
    const isRight = e.button === 2;

    if (isTouch || isRight) {
      isStirDrag = true;
      setNDCFromEvent(e);
      updatePointerWorldFromNDC();
      lastPointerWorld.copy(pointerWorld);
      lastPointerTime = performance.now();
      pointerVel.set(0,0,0);
      velSmoothed.set(0,0,0);
      injectStirBlob();
    } else {
      isOrbitDrag = true;
      lastOrbitX = e.clientX;
      lastOrbitY = e.clientY;
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (isOrbitDrag) {
      const dx = e.clientX - lastOrbitX;
      const dy = e.clientY - lastOrbitY;
      lastOrbitX = e.clientX; lastOrbitY = e.clientY;
      camPhi   -= dx * 0.005;
      camTheta -= dy * 0.005;
      updateCamera();
    }
    if (isStirDrag) {
      setNDCFromEvent(e);
      updatePointerWorldFromNDC();
      updatePointerVelocity();
      injectStirBlob();
    }
  });

  canvas.addEventListener("pointerup", () => { isOrbitDrag = false; isStirDrag = false; });
  canvas.addEventListener("pointercancel", () => { isOrbitDrag = false; isStirDrag = false; });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    camRadius *= (e.deltaY > 0) ? 1.08 : 0.92;
    camRadius = Math.max(1.5, Math.min(40, camRadius));
    updateCamera();
  }, { passive: false });

  // UI wiring
  const ui = document.getElementById("ui");
  const fpsEl = document.getElementById("fps");

  function bindSlider(id, outId, key, fmt=2, route="uniform"){
    const el = document.getElementById(id);
    const out = outId ? document.getElementById(outId) : null;
    const update = () => {
      const v = parseFloat(el.value);
      params[key] = v;
      if (out) out.textContent = (fmt === 0 ? String(Math.round(v)) : v.toFixed(fmt));
      if (route === "lighting") applyLighting();
      else if (route === "material") applyMaterial();
      else setUniformsLive();
    };
    el.addEventListener("input", update);
    update();
  }
  function bindToggle(id, key, fn){
    const el = document.getElementById(id);
    const update = () => { params[key] = el.checked; fn(); };
    el.addEventListener("change", update);
    update();
  }

  bindSlider("amp", "ampV", "amp");
  bindSlider("speed", "speedV", "speed");
  bindSlider("cubeScale", "cubeScaleV", "cubeScale");
  bindSlider("spin", "spinV", "spin");

  bindSlider("brightness", "brightnessV", "brightness");
  bindSlider("stirStrength", "stirStrengthV", "stirStrength");
  bindSlider("stirRadius", "stirRadiusV", "stirRadius");
  bindSlider("stirPersist", "stirPersistV", "stirPersist");
  bindSlider("stirDecay", "stirDecayV", "stirDecay");

  bindToggle("invertStir", "invertStir", setUniformsLive);
  bindToggle("debugField", "debugField", () => { if (!params.debugField) clearDebug(); });

  bindToggle("lightsEnabled", "lightsEnabled", applyLighting);
  bindToggle("shadowsEnabled", "shadowsEnabled", applyLighting);

  bindSlider("ambientI", "ambientIV", "ambientI", 2, "lighting");
  bindSlider("keyI", "keyIV", "keyI", 2, "lighting");
  bindSlider("keyAz", "keyAzV", "keyAz", 0, "lighting");
  bindSlider("keyEl", "keyElV", "keyEl", 0, "lighting");
  bindSlider("fillI", "fillIV", "fillI", 2, "lighting");
  bindSlider("fillAz", "fillAzV", "fillAz", 0, "lighting");
  bindSlider("fillEl", "fillElV", "fillEl", 0, "lighting");
  bindSlider("rimI", "rimIV", "rimI", 2, "lighting");
  bindSlider("rimAz", "rimAzV", "rimAz", 0, "lighting");
  bindSlider("rimEl", "rimElV", "rimEl", 0, "lighting");

  bindSlider("rough", "roughV", "roughness", 2, "material");
  bindSlider("metal", "metalV", "metalness", 2, "material");

  const colorMode = document.getElementById("colorMode");
  const colorA = document.getElementById("colorA");
  const colorB = document.getElementById("colorB");
  colorMode.addEventListener("change", () => { params.colorMode = parseInt(colorMode.value, 10); setUniformsLive(); });
  colorA.addEventListener("input", () => { params.colorA.set(colorA.value); setUniformsLive(); });
  colorB.addEventListener("input", () => { params.colorB.set(colorB.value); setUniformsLive(); });

  const b2k = document.getElementById("b2k");
  const b8k = document.getElementById("b8k");
  const b20k = document.getElementById("b20k");
  const pauseBtn = document.getElementById("pause");
  const resetBtn = document.getElementById("reset");
  const hideBtn = document.getElementById("hide");
  const stirToggleBtn = document.getElementById("stirToggle");

  function setPresetActive(count){
    b2k.classList.toggle("primary", count === 2000);
    b8k.classList.toggle("primary", count === 8000);
    b20k.classList.toggle("primary", count === 20000);
  }
  function setCount(count){ setPresetActive(count); buildMesh(count); }
  b2k.onclick = () => setCount(2000);
  b8k.onclick = () => setCount(8000);
  b20k.onclick = () => setCount(20000);

  resetBtn.onclick = () => applyRandomDistribution(currentCount);
  hideBtn.onclick = () => ui.classList.toggle("hidden");

  let paused = false;
  function togglePause(){
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume (Space)" : "Pause (Space)";
  }
  pauseBtn.onclick = () => togglePause();

  function updateStirUI(){
    stirToggleBtn.textContent = params.stirEnabled ? "Stir: ON (M)" : "Stir: OFF (M)";
    stirToggleBtn.classList.toggle("toggled", params.stirEnabled);
  }
  stirToggleBtn.onclick = () => { params.stirEnabled = !params.stirEnabled; updateStirUI(); setUniformsLive(); };
  updateStirUI();

  // Loop + FPS
  const clock = new THREE.Clock();
  let lastT = 0;
  let frames = 0;
  let fpsLast = performance.now();

  function updateFPS(){
    frames++;
    const now = performance.now();
    const dt = now - fpsLast;
    if (dt >= 400) {
      fpsEl.textContent = `FPS: ${(frames * 1000 / dt).toFixed(0)}`;
      frames = 0;
      fpsLast = now;
    }
  }

  function tick(){
    const rawT = clock.getElapsedTime();
    const t = paused ? lastT : rawT;
    if (!paused) lastT = t;

    // blob decay
    const dt = 1/60;
    stirState.age += dt;
    const decayRate = params.stirDecay / Math.max(0.05, params.stirPersist);
    stirState.strength *= Math.exp(-decayRate * dt);

    if (isStirDrag) {
      stirState.strength = Math.max(stirState.strength, 0.55);
      stirState.vel.lerp(pointerVel, 0.25);
      stirState.pos.lerp(pointerWorld, 0.35);
    } else {
      stirState.pos.addScaledVector(stirState.vel, dt * 0.25);
      stirState.vel.multiplyScalar(0.92);
    }

    const sh = material?.userData?.shader;
    if (sh) {
      sh.uniforms.uTime.value = t;
      if (!isStirDrag) pointerVel.multiplyScalar(0.85);

      sh.uniforms.uPointerPos.value.copy(pointerWorld);
      sh.uniforms.uPointerVel.value.copy(pointerVel);
      sh.uniforms.uBlobPos.value.copy(stirState.pos);
      sh.uniforms.uBlobVel.value.copy(stirState.vel);
      sh.uniforms.uBlobStrength.value = Math.max(0.0, Math.min(1.0, stirState.strength));
    }

    renderer.render(scene, camera);

    if (params.debugField && hasDbg) drawDebug();
    else clearDebug();

    updateFPS();
    requestAnimationFrame(tick);
  }

  // Hotkeys
  addEventListener("keydown", (e) => {
    if (e.repeat) return;
    const k = e.key.toLowerCase();
    if (k === " ") { e.preventDefault(); togglePause(); }
    else if (k === "r") { applyRandomDistribution(currentCount); }
    else if (k === "1") { setCount(2000); }
    else if (k === "2") { setCount(8000); }
    else if (k === "3") { setCount(20000); }
    else if (k === "h") { ui.classList.toggle("hidden"); }
    else if (k === "m") { params.stirEnabled = !params.stirEnabled; updateStirUI(); setUniformsLive(); }
    else if (k === "d") {
      params.debugField = !params.debugField;
      document.getElementById("debugField").checked = params.debugField;
      if (!params.debugField) clearDebug();
    }
  });

  // Boot
  setPresetActive(8000);
  buildMesh(8000);
  applyLighting();
  applyMaterial();
  setUniformsLive();
  tick();

} catch (e) {
  showError(e);
}
</script>
</body>
</html>
